# Add names ---------------------------------------------------------------

#' Set names of a vector
#'
#' @param x Vector
#' @param names Character vector of names (or coercible to a character vector). If length of names is shorter than length of `x`, names are recycled. Default entry will name each component of `x` with it's value
#' @returns Named version of input
#' @export
set_names <- function(x, names = x) {
  names(x) <- rep_len(as.character(names), length(x))
  x
}

# Edit names --------------------------------------------------------------

#' Swap values with names or vice versa
#'
#' @param x Named vector
#' @returns Vector with names of `x` now forming values of output vector and values of `x` now forming names of output vector
#' @export
swap_names_vals <- function(x) {
  values <- names(x)
  if (is.null(values)) stop("Input to swap_names_vals() must be a named vector", call. = FALSE)
  names(values) <- x
  values
}

# Information about names -------------------------------------------------

#' Determine whether each elements is named
#'
#' @param x List or vector
#' @returns Logical with length equal to `length(x)`
#' @export
is_named <- function(x) {
  x_names <- names(x)
  if (is.null(x_names)) return(rep(FALSE, length(x)))
  !is.na(x_names) & nzchar(x_names)
}

#' Determine whether any elements are named
#'
#' @param x List or vector
#' @returns Logical of length 1
#' @export
any_named <- function(x) {
  x_names <- names(x)
  if (is.null(x_names)) {
    FALSE
  } else if (any(nzchar(x_names))) {
    TRUE
  } else if (all(is.na(x_names))) {
    FALSE
  } else {
    TRUE
  }
}

#' Alias for `any_named`
#'
#' @rdname any_named
#' @export
has_names <- any_named

#' Determine whether all elements are named
#'
#' @param x List or vector
#' @returns Logical of length 1
#' @export
all_named <- function(x) all(is_named(x))

#' Determine whether names contain a specified pattern
#'
#' Equivalent to `grepl(pattern = pattern, x = names(x))`
#' @param x Data frame, matrix, list, or named vector
#' @param pattern Pattern in `names(x)` to search
#' @param invert If `TRUE`, search will be performed for names of `x` that do not contain `pattern`. Equivalent of `!name_contains(x)`
#' @param ignore_case If `FALSE` (default), case of both `names(x)` and `pattern` are ignored in search. If `TRUE`, case used in `names(x)` and `pattern` must match
#' @param ... Arguments passed to `str_contains`
#' @returns Logical vector with length equal to `length(x)` (or `ncol(x)` if `x` is a matrix)
#' @export
name_contains <- function(x, pattern, invert = FALSE, ignore_case = FALSE, ...) {
  x_names <- if (is.matrix(x)) {
    colnames(x)
  } else {
    names(x)
  }
  str_contains(x_names, pattern = pattern, invert = invert, ignore_case = ignore_case, ...)
}

# Helpers -----------------------------------------------------------------

#' Force an object to have names
#'
#' @param x Data frame, list, or vector
#' @param prefix Prefix for names. Enter as length 1 character vector. Default is `"v"`
#' @noRd
.force_names <- function(x, prefix = "V") {
  if (is.null(x_names <- names(x))) return(paste0(prefix, seq_along(x)))
  idx <- x_names == ""
  x_names[idx] <- paste0(prefix, seq_len(sum(idx)))
  x_names
}

#' Create unique name
#'
#' @param .new Proposed name. Enter as string
#' @param .old Existing names. Enter as character vector
#' @param .sep Separator to use for new names. New names are generated by appending `sep` followed by an integer to `.new`. The integer used will be the first (starting from 1) that doesn't result in a name that already exists in `.old`. Default is `"_"`
#' @noRd
.safe_name <- function(.new, .old, .sep = "_") {
  # .new must be after .old to ensure it doesn't take precedence over existing names
  z <- c(.old, .new)
  make.unique(z, sep = .sep)[length(z)]
}
