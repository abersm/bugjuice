# View colors -------------------------------------------------------------

#' Display colors as swatch
#'
#' @param ... List, character vector, or comma separated list of colors as quoted color names or hexadecimal codes
#' @param direction Orientation of color squares. Options: `"vertical"` (default) or `"horizontal"`. Enter as quoted direction
#' @param border_thickness Square border thickness
#' @param reverse Reverse order of colors
#' @export
swatch <- function(..., direction = c("vertical", "horizontal"), border_thickness = 2.5, reverse = FALSE) {
  pkg_required("graphics")
  colors <- .color_input(...)
  direction <- match.arg(direction, choices = c("vertical", "horizontal"))
  if (reverse) {
    colors <- Rev(colors)
  }
  n_colors <- length(colors)
  size_half <- 0.45/(n_colors + 1)
  z <- 1/(n_colors + 1)
  a <- z*seq_len(n_colors)
  b <- rep(z*(n_colors + 1)/2, n_colors)
  old_pars <- graphics::par(mai = c(0, 0, 0, 0), bg = "white")
  on.exit(graphics::par(old_pars))
  dev_size <- grDevices::dev.size()
  dev_ratio <- dev_size[2L]/dev_size[1L]
  plot(x = NA, y = NA, xlim = c(-0.1, 1.1), ylim = 0.5 + c(-1, 1)*dev_ratio*0.6, xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n", asp = 1)
  if (direction == "vertical") {
    graphics::rect(xleft = b - size_half, ybottom = a - size_half, xright = b + size_half, ytop = a + size_half, col = colors, border = "black", lwd = border_thickness)
  } else {
    graphics::rect(xleft = a - size_half, ybottom = b - size_half, xright = a + size_half, ytop = b + size_half, col = colors, border = "black", lwd = border_thickness)
  }
}

#' Display colors and hexadecimal codes
#'
#' Inspired by `scales::show_col`
#' @rdname swatch
#' @param ... List, character vector, or comma separated list of colors as quoted color names or hexadecimal codes
#' @param hex If `TRUE` (default), hexadecimal codes of input colors displayed
#' @param ncol Number of columns in output
#' @export
pal <- function(..., hex = TRUE, ncol = NULL) {
  pkg_required("graphics")
  colors <- if (is.list(colors <- c(...))) purrr::flatten(colors) else colors
  colors <- col2hex(colors)
  n_colors <- length(colors)
  ncol <- ncol %||% if (n_colors == 3L) {
    3L
  } else if (n_colors == 8L) {
    4L
  } else if (n_colors == 10L) {
    5L
  } else {
    ceiling(sqrt(n_colors))
  }
  colors <- matrix(c(colors, rep(NA, ceiling(n_colors/ncol)*ncol - n_colors)), ncol = ncol, byrow = TRUE)
  old_pars <- graphics::par(pty = "s", mar = c(0, 0, 0, 0))
  on.exit(graphics::par(old_pars))
  size <- max(dim(colors))
  plot(c(0, size), c(0, -size), type = "n", xlab = "", ylab = "", axes = FALSE)
  graphics::rect(col(colors) - 1, -row(colors) + 1, col(colors), -row(colors), col = colors, border = "black", lwd = 1)
  if (hex) {
    text_colors <- clr_text(colors)
    font_size <- if (ncol < 4) 1 else if (ncol > 4) 0.5 else 0.75
    graphics::text(col(colors) - 0.5, -row(colors) + 0.5, colors, cex = font_size, col = text_colors)
  }
}

# Create colors -----------------------------------------------------------

#' Mix 2 colors
#'
#' @param ... Character vector or comma separated list of colors. Enter as quoted color names or hexadecimal codes
#' @param ratio Ratio of 1st color to 2nd color. Enter as numeric (i.e. 3 for 3:1 mixing). Default is `1` (i.e. 1:1 mixing)
#' @param prop_color1 Proportion of 1st color relative to second color in mixing. Enter as numeric 0-1. If value entered for `prop_color1`, then `ratio` is ignored
#' @param return_input If `FALSE` (default), only mixed color is returned. If `TRUE`, input color included in output
#' @returns Hexadecimal code of color generated by mixing input colors +/- input colors
#' @export
clr_mix <- function(..., ratio = 1, prop_color1 = NULL, return_input = FALSE) {
  if (length(colors <- c(...)) > 2) {
    message(sprintf("> 2 colors entered as input to clr_mix()\nOnly the first (%s) and second (%s) colors will be mixed", colors[1L], colors[2L]))
  }
  prop_color1 <- prop_color1 %||% (ratio/(ratio + 1))
  new_col <- rowSums(grDevices::col2rgb(colors[2L]))*prop_color1 + grDevices::col2rgb(colors[1L])*(1 - prop_color1)
  new_col <- grDevices::rgb(new_col[1, ], new_col[2, ], new_col[3, ], maxColorValue = 255)
  c(if (return_input) colors, new_col)
}

#' Opposite color
#'
#' Functionality from Gaston Sanchez's excellent package colortools
#' @rdname clr_mix
#' @param color Hexadecimal code or color name. Enter as length 1 character vector
#' @param return_input If `FALSE` (default), only mixed color is returned. If `TRUE`, input color included in output
#' @returns Hexadecimal codes as character vector containing opposite color +/- input color
#' @export
clr_opposite <- function(color, return_input = FALSE) {
  rgb_col <- grDevices::col2rgb(color)
  hsv_col <- grDevices::rgb2hsv(rgb_col)[, 1]
  hue <- hsv_col[1L]
  sat <- hsv_col[2L]
  val <- hsv_col[3L]
  cols <- seq(hue, hue + 1, by = 1/12)
  cols <- cols[seq_len(12)]
  idx <- cols > 1
  cols[idx] <- cols[idx] - 1
  cols <- grDevices::hsv(cols, sat, val)
  if (startsWith(color, "#") && nchar(color) == 9) {
    cols <- paste(cols, substr(color, 8, 9), sep = "")
  }
  idx <- if (return_input) c(1, 7) else 7
  cols[idx]
}

#' Lighter color
#'
#' @rdname clr_mix
#' @param color Enter as character vector of color names or hexadecimal codes
#' @param lightness Amount of transparency to add. Enter as numeric 0-1. Default is `0.5`. To create color eqivalent to output of ggplot with alpha applied, enter 1 - a
#' @param return_input If `FALSE` (default), only mixed color is returned. If `TRUE`, input color is included in output
#' @returns Hexadecimal code of lightened color +/- input color
#' @export
clr_lighter <- function(color, lightness = 0.5, return_input = FALSE) {
  color <- col2hex(color)
  new_color <- t.default(grDevices::col2rgb(color, alpha = TRUE) + c(rep(lightness, 3), 0)*(255 - grDevices::col2rgb(color, alpha = TRUE)))
  new_color <- grDevices::rgb(new_color, alpha = new_color[, 4], maxColorValue = 255)
  if (return_input) c(color, new_color) else new_color
}

#' Create color when alpha is applied to base color
#'
#' @rdname clr_mix
#' @param color Enter as character vector of color names or hexadecimal codes
#' @param alpha Transparency. Default is `0.8`
#' @param return_input If `FALSE` (default), only new color is returned. If `TRUE`, input color is included in output
#' @returns Hexadecimal code of new color
#' @export
clr_alpha_filter <- function(color, alpha = 0.8, return_input = FALSE) {
  color <- col2hex(color)
  new_color <- t.default(grDevices::col2rgb(color, alpha = TRUE) + c(rep(1 - alpha, 3), 0)*(255 - grDevices::col2rgb(color, alpha = TRUE)))
  new_color <- gsub("FF$", "", grDevices::rgb(new_color, alpha = new_color[, 4], maxColorValue = 255))
  if (return_input) c(color, new_color) else new_color
}

#' Darker color
#'
#' @rdname clr_mix
#' @param color Enter as character vector of color names or hexadecimal codes
#' @param darkness Fraction (numeric 0-1) of black to add to starting color. Default is `0.2`
#' @param return_input If `FALSE` (default), only mixed color is returned. If `TRUE`, input color included in output
#' @returns Hexadecimal code of darkened color +/- input color
#' @export
clr_darker <- function(color, darkness = 0.2, return_input = FALSE) {
  color <- col2hex(color)
  new_color <- t.default(grDevices::col2rgb(color, alpha = TRUE)*c(rep(1 - darkness, 3), 1))
  new_color <- grDevices::rgb(new_color, alpha = new_color[, 4], maxColorValue = 255)
  c(if (return_input) color, new_color)
}

#' Decrease color saturation
#'
#' @rdname clr_mix
#' @param color Enter as character vector of color names or hexadecimal codes
#' @param saturation Level of saturation. Enter as numeric 0-1. Default is `0.5`
#' @param return_input If `FALSE` (default), only mixed color is returned. If `TRUE`, input color included in output
#' @returns Hexadecimal code of desaturated color +/- input color
#' @export
clr_desaturate <- function(color, saturation = 0.5, return_input = FALSE) {
  color <- col2hex(color)
  desaturate <- function(x) {
    new_color <- do.call(grDevices::rgb2hsv, structure(as.list(grDevices::col2rgb(x)[, 1]), names = c("r", "g", "b")))
  new_color["s", ] <- new_color["s", ]*saturation
  do.call(grDevices::hsv, as.list(new_color[, 1]))
  }
  new_color <- vapply(color, desaturate, character(1), USE.NAMES = FALSE)
  if (return_input) interleave(color, new_color) else new_color
}

#' Generate continuous color scale from 2-3 colors
#'
#' Functionality from gplots package
#' @param ... Colors. If 3 colors are entered, output is a continuous scale using 2nd color as midpoint
#' @param n Number of colors in output color scheme. Default is `20`
#' @returns Hexadecimal codes for continuous color scale
#'
#' @examples
#'
#' # clr_continuous(c("#2166AC", "#F7F7F7", "#B2182B"), n = 20)
#' # clr_continuous("blue", "forestgreen", "gold", "orange", "red", n = 20)
#' # clr_continuous(c("#2166AC", "#B2182B"), n = 20)
#'
#' @export
clr_continuous <- function(..., n = 20) grDevices::colorRampPalette(col2hex(.color_input(...)))(n)

#' Create shades of grey
#'
#' @param n Number of colors. Default is `20`
#' @param start,end Hues used for first and last colors, respectively. Enter as numeric 0-1
#' @param reverse Whether to reverse default color order. If `FALSE` (default), colors are ordered from darkest to lightest. If `TRUE`, colors are ordered from lightest to darkest
#' @returns Hexadecimal codes
#'
#' @examples
#' # clr_continuous_grey(20)
#'
#' @export
clr_continuous_grey <- function(n = 20, start = 0.3, end = 0.8, reverse = FALSE) {
  grDevices::grey.colors(n = n, start = start, end = end, gamma = 2.2, rev = reverse)
}

#' Viridis palette
#'
#' @param n Number of colors. Default is `20`
#' @param start,end Hues used for first and last colors, respectively
#' @param palette Options include `"viridis"` (default), `"plasma"`, `"magma"`, `"inferno"`, `"cividis"`, `"rocket"`, `"turbo"`, `"mako"`
#' @param reverse Whether to reverse default color order. If `FALSE` (default), colors are ordered from darkest to lightest. If `TRUE`, colors are ordered from lightest to darkest
#' @param alpha Transparency. Numeric in between 0 and 1. Default is `1`
#' @returns Hexadecimal codes for viridis color scale
#'
#' @examples
#' # clr_continuous_viridis(20)
#'
#' @importFrom scales viridis_pal
#' @export
clr_continuous_viridis <- function(n = 20, start = 0, end = 1, palette = "viridis", reverse = FALSE, alpha = 1) {
  scales::viridis_pal(alpha = alpha, begin = start, end = end, option = palette, direction = if (reverse) -1 else 1)(n)
}

#' Spectral palette
#'
#' @param n Number of colors. Default is `20`
#' @param type Options: `"dark"` (default), `"medium"`, `"light"`, `"turbo"`
#' @examples
#'
#' # clr_continuous_spectral(20)
#'
#' @export
clr_continuous_spectral <- function(n = 20, type = "dark") {
  # grDevices::colorRampPalette(hsv(h = c(seq(2/3, 0.5, len = 10),  seq(0.5, 0, len = 10)), s = rep(saturation, len = 20), v = 1))(n)
  if (type == "turbo") return(scales::viridis_pal(option = "turbo")(n))
  colors <- switch(type,
         dark = c("#5E4FA2", "#555AA7", "#4C66AD", "#4371B2", "#3A7DB8", "#3389BC", "#3D95B7", "#48A0B2", "#52ACAD", "#5DB8A8", "#68C3A4", "#76C8A4", "#84CEA4", "#93D3A4", "#A1D9A4", "#AEDEA3", "#BAE3A0", "#C6E89E", "#D2ED9B", "#DEF299", "#E8F59B", "#EDF7A3", "#F2F9AB", "#F7FBB3", "#FCFDBB", "#FEFBB9", "#FEF5AF", "#FEEFA4", "#FEE899", "#FEE28F", "#FDD985", "#FDCF7D", "#FDC574", "#FDBB6C", "#FDB163", "#FBA45C", "#F99756", "#F88A50", "#F67C4A", "#F46F44", "#EE6544", "#E85B47", "#E25249", "#DB484C", "#D53E4E", "#CA324C", "#BF2649", "#B41947", "#A90D44", "#9E0142"),
         medium = c("dodgerblue4", "steelblue2", "olivedrab3", "darkgoldenrod1", "brown"),
         light = ,
         c("blue3", "blue", "turquoise", "green", "yellow", "orange", "red", "darkred"))
  grDevices::colorRampPalette(colors)(n)
}

# Analysis ----------------------------------------------------------------

#' Calculate luminance of a color
#'
#' @param color Color entered as quoted color or hexadecimal code
#' @returns Numeric with same length as input
#' @export
clr_luminance <- function(color) {
  col_rgb <- t.default(grDevices::col2rgb(color))/255
  col_rgb[] <- ifelse(col_rgb <= 0.03928, col_rgb/12.92, ((col_rgb + 0.055)/1.055)^2.4)
  as.numeric(col_rgb %*% c(0.2126, 0.7152, 0.0722))
}

#' Calculate contrast ratio between colors
#'
#' Functionality from colorspace package
#' @rdname clr_text
#' @param col1,col2 Colors 1 and 2. col1 can be vector of colors. Default for col2 is `"white"`
#' @param as_df If `TRUE`, output will be data frame with columns for col1, col2, ratio, contrast
#' @returns Ratio of luminance for 2 colors. > 3 decent, > 4.5 preferred. If `as_df = TRUE`, output will be data frame with columns col1, col2, ratio, contrast
#' @export
clr_contrast_ratio <- function(col1, col2 = "white", as_df = FALSE) {
  r <- (clr_luminance(col1) + 0.05)/(clr_luminance(col2) + 0.05)
  r[r < 1] <- 1/r[r < 1]
  if (as_df) {
    df <- vec_to_df(col1 = col1, col2 = col2, ratio = r)
    df$contrast <- ifelse(r > 4.5, "High", ifelse(r > 3, "Medium", "Low"))
    df[-xtfrm.default(df$ratio), , drop = FALSE]
  } else {
    r
  }
}

#' Determine whether black or white text is better for a given background color
#'
#' @param ... List, character vector, or comma separated list of colors as quoted color names or hexadecimal codes
#'
#' @examples
#' # clr_text(c("#0072B5", "#BC3C29"))
#'
#' @export
clr_text <- function(...) {
  colors <- .color_input(...)
  ifelse(clr_contrast_ratio(colors, "white") > clr_contrast_ratio(colors, "black"), "white", "black")
}

# Color conversion --------------------------------------------------------

#' Convert CMYK to hexadecimal code
#'
#' @param c Cyan percentage. Enter as integer 0-100
#' @param m Magenta percentage. Enter as integer 0-100
#' @param y Yellow percentage. Enter as integer 0-100
#' @param k Black percentage. Enter as integer 0-100
#' @param alpha Transparency. Enter as numeric 0-1. If `alpha = NULL`, transparency is ignored
#' @returns Hexadecimal code(s). Length equal to `length(c)`
#' @export
cmyk2hex <- function(c, m, y, k, alpha = NULL) {
  cols <- 1 - matrix(c(c, m, y, k)/100, byrow = TRUE, nrow = 4)
  cols <- apply(cols, 2, function(x) x*x[4L])
  rgb2hex(r = cols[-4, ], alpha = alpha)
}

#' Get hexadecimal code for named color
#'
#' @rdname cmyk2hex
#' @param x Color entered as quoted named color or quoted hexadecimal code
#' @returns Hexadecimal code as character vector with length equal to input
#' @export
col2hex <- function(x) {
  col <- grDevices::col2rgb(x)/255
  grDevices::rgb(red = col[1, ], green = col[2, ], blue = col[3, ])
}

#' Convert rgb to hsl color space
#'
#' Functionality from plotwidgets package
#' @rdname cmyk2hex
#' @param x Matrix with 3 rows for red, green, blue
#' @returns Matrix with 3 rows for hue, saturation, luminance
#' @export
rgb2hsl <- function(x) {
  if (nrow(x) == 4) {
    alpha <- x[4, , drop = FALSE]
    x <- x[-4, , drop = FALSE]
  } else {
    alpha <- NULL
  }
  x <- x/255
  x_min <- apply(x, 2, min)
  x_max <- apply(x, 2, max)
  d <- x_max - x_min
  L <- (x_max + x_min)/2
  S <- d/(1 - abs(2*L - 1))
  sel <- d == 0
  S[sel] <- 0
  wmax <- apply(x, 2, which.max)
  H <- L
  HR <- (x[2, ] - x[3, ])/d
  HG <- 2 + (x[3, ] - x[1, ])/d
  HB <- 4 + (x[1, ] - x[2, ])/d
  sel <- wmax == 1
  H[sel] <- HR[sel]
  sel <- wmax == 2
  H[sel] <- HG[sel]
  sel <- wmax == 3
  H[sel] <- HB[sel]
  H <- (H*60) %% 360
  H[x_min == x_max] <- 0
  rbind(h = H, s = S, l = L, alpha = alpha)
}

#' Convert from hexadecimal code or named color to hsl
#'
#' @rdname cmyk2hex
#' @param x Color as quoted color name or quoted hexadecimal code
#' @returns Matrix with 3 rows for hue, saturation, luminance
#' @export
col2hsl <- function(x) rgb2hsl(grDevices::col2rgb(x))

#' Convert from hsl to rgb color space
#'
#' Functionality from plotwidgets package
#' @rdname cmyk2hex
#' @param x Matrix with 3 rows for hue, saturation, luminance
#' @returns Matrix with 3 rows for red, green, blue. 1 column per color
#' @export
hsl2rgb <- function(x) {
  if (nrow(x) == 4) {
    alpha <- x[4, , drop = FALSE]
    x <- x[-4, , drop = FALSE]
  } else {
    alpha <- NULL
  }
  H <- x[1, ]
  S <- x[2, ]
  L <- x[3, ]
  C <- (1 - abs(2*L - 1))*S
  X <- C*(1- abs(((H/60) %% 2) - 1))
  m <- L - C/2
  rgb <- matrix(0, ncol = ncol(x), nrow = 3)
  rownames(rgb) <- c("red", "green", "blue")
  iX <- c(2, 1, 3, 2, 1, 3)
  iC <- c(1, 2, 2, 3, 3, 1)
  for (i in seq_len(6)) {
    sel <- 60*(i - 1) <= H & H < 60*i
    kX <- iX[i]
    kC <- iC[i]
    rgb[kX, sel] <- X[sel]
    rgb[kC, sel] <- C[sel]
  }
  rgb <- rgb + rep(m, each = 3)
  rgb <- round(rgb*255)
  if (is.null(alpha)) rgb else rbind(rgb, alpha = alpha)
}

#' Convert rgb to hexadecimal code
#'
#' @rdname cmyk2hex
#' @param r Either red color as integer of values 0-255 or a matrix with rows for red, green, blue (can also contain alpha) and 1 column per color
#' @param g,b Green and blue as integer vector of values 0-255
#' @param alpha Transparency. Enter as numeric 0-1. If `r` is a matrix with alpha in 4th row, `alpha` will override 4th row of `r`. If `alpha = NULL`, transparency is ignored
#' @returns Hexadecimal code as character vector with length equal to `length(r)` (or `ncol(r)` if `r` is a matrix
#' @export
rgb2hex <- function(r, g = NULL, b = NULL, alpha = NULL) {
  if (is.matrix(r)) {
    alpha <- if (!is.null(alpha)) {
      alpha*255
    } else if (nrow(r) == 4L) {
      r[4, ]
    } else {
      NULL
    }
    grDevices::rgb(r[1, ], r[2, ], r[3, ], alpha = alpha, maxColorValue = 255)
  } else {
    if (!is.null(alpha)) {
      alpha <- alpha*255
    }
    grDevices::rgb(red = r, green = g, blue = b, alpha = alpha, maxColorValue = 255)
  }
}

#' Convert hsl to hexadecimal code
#'
#' @rdname cmyk2hex
#' @param x Matrix with 3 rows for hue, saturation, luminance
#' @returns Hexadecimal code as character vector with length equal to `ncol(x)`
#' @export
hsl2hex <- function(x) {
  x <- hsl2rgb(x)
  grDevices::rgb(x[1, ], x[2, ], x[3, ], alpha = if (nrow(x) == 4) x[4, ] else NULL, maxColorValue = 255)
}

# Colorblind --------------------------------------------------------------

#' Convert colors to those that would be viewed by an individual with deuteranopia colorblindness
#'
#' Functionality from Emil Hvitfeldt's excellent package prismatic
#' @param ... Colors. Enter as comma separated list of quoted color names or hexadecimal codes with or without `c()`
#' @returns Hexadecimal code as character vector containing color as viewed by an individual with deuteranopia colorblindness
#'
#' @examples
#'
#' # clr_blind_deutanan(c("#0072B5", "#BC3C29"))
#'
#' @export
clr_blind_deutanan <- function(...) {
  z <- grDevices::col2rgb(.color_input(...))
  m <- matrix(c(0.367322, 0.280085, -0.01182, 0.860646, 0.672501, 0.04294, -0.227968, 0.047413, 0.968881), ncol = 3)
  z <- t.default(z) %*% t.default(m)
  z[z > 255] <- 255
  z[z < 0] <- 0
  z <- t.default(z)
  grDevices::rgb(z[1, ], z[2, ], z[3, ], maxColorValue = 255)
}

#' Convert colors to those that would be viewed by an individual with protanopia colorblindness
#'
#' Functionality from Emil Hvitfeldt's excellent package prismatic
#' @rdname clr_blind_deutanan
#' @returns Hexadecimal code as character vector containing color as viewed by an individual with protanopia colorblindness
#' @export
clr_blind_protan <- function(...) {
  z <- grDevices::col2rgb(.color_input(...))
  m <- matrix(c(0.152286, 0.114503, -0.003882, 1.052583, 0.786281, -0.048116, -0.204868, 0.099216, 1.051998), ncol = 3)
  z <- t.default(z) %*% t.default(m)
  z[z > 255] <- 255
  z[z < 0] <- 0
  z <- t.default(z)
  grDevices::rgb(z[1, ], z[2, ], z[3, ], maxColorValue = 255)
}

#' Convert colors to those that would be viewed by an individual with tritanopia colorblindness
#'
#' Functionality from Emil Hvitfeldt's excellent package prismatic
#' @rdname clr_blind_deutanan
#' @returns Hexadecimal code as character vector containing color as viewed by an individual with tritanopia colorblindness
#' @export
clr_blind_tritan <- function(...) {
  z <- grDevices::col2rgb(.color_input(...))
  m <- matrix(c(1.255528, -0.078411, 0.004733, -0.076749, 0.930809, 0.691367, -0.178779, 0.147602, 0.3039), ncol = 3)
  z <- t.default(z) %*% t.default(m)
  z[z > 255] <- 255
  z[z < 0] <- 0
  z <- t.default(z)
  grDevices::rgb(z[1, ], z[2, ], z[3, ], maxColorValue = 255)
}

#' Transform colors to greyscale
#'
#' Functionality from Emil Hvitfeldt's excellent package prismatic
#' @param ... List, character vector, or comma separated list of colors as quoted color names or hexadecimal codes
#' @param method Method for transformation. Options: `"luma"` (default), `"average"`, `"min_decomp"`, `"max_decomp"`, `"red_channel"`, `"green_channel"`, `"blue_channel"`
#' @returns Hexadecimal codes as character vector of greyscale colors
#' @export
clr_as_greyscale <- function(..., method = "luma") {
  color_rgb <- grDevices::col2rgb(.color_input(...))
  color_rgb <- switch(method,
                      luma = matrix(c(0.2126, 0.7152, 0.0722), nrow = 1) %*% color_rgb/256,
                      average = matrix(c(1/3, 1/3, 1/3), nrow = 1) %*% color_rgb/256,
                      min_decomp = apply(color_rgb/256, 2, min),
                      max_decomp = apply(color_rgb/256, 2, max),
                      red_channel = (color_rgb/256)["red", ],
                      green_channel = (color_rgb/256)["green", ],
                      blue_channel = (color_rgb/256)["blue", ])
  grDevices::rgb(color_rgb, color_rgb, color_rgb, color_rgb)
}

#' Alias for `clr_as_greyscale`
#' @rdname clr_as_greyscale
#' @export
greyscale <- clr_as_greyscale

# Sort colors -------------------------------------------------------------

#' Sort hsl colors
#'
#' @param x Either a character vector (color names or hexadecimal codes) or matrix (rows for rgb or hsl)
#' @param order Options: `"hex"` (alphabetical), `"name"` (alphabetical based on color names, or a vec containing 1 or more rows in rgb, hsl, or hcl to sort by in order of importance (i.e. `c("r", "g", "b")`, `c("h", "s", "l")`, `"r"`, `"l"`, etc.). Enter as character vector. Default is `c("h", "s", "l")`
#' @param rev Logical vector with length of 1 or same length as `order` indicating whether to reverse the order for each component in `order`. To sort from darkest to lightest, set `order = c("h", "s", "l")` and `rev = c(FALSE, FALSE, TRUE)`
#' @returns Character vector of hexadecimal codes
#' @export
clr_sort <- function(x, order = c("h", "s", "l"), rev = FALSE) {
  n_order <- length(order)
  rev <- rep(rev, length.out = n_order)
  if (is.character(x)) {
    if (!all(startsWith(x, "#")) && n_order == 1L && order == "name") {
      x <- sort(x)
      if (rev) {
        x <- rev(x)
      }
      return(col2hex(x))
    } else {
      x <- col2hex(x)
      if (length(order) == 1L && order == "hex") {
        x <- sort(x)
        if (rev) {
          x <- rev(x)
        }
        return(x)
      } else {
        sort_type <- if (any(c("r", "g", "b") %in% order)) "rgb" else "hsl"
        x <- if (sort_type == "rgb") {
          grDevices::col2rgb(x)
        } else {
          col2hsl(x)
        }
      }
    }
  } else {
    sort_type <- if (any(c("r", "g", "b") %in% order)) "rgb" else "hsl"
    rows <- rownames(x)
    if ("red" %in% rows && sort_type == "hsl") {
      x <- rgb2hsl(x)
    } else if ("h" %in% rows && sort_type == "rgb") {
      x <- hsl2rgb(x)
    }
  }

  x <- matrix_to_df(t.default(x))
  names(x) <- if (sort_type == "rgb") c("r", "g", "b") else c("h", "s", "l")
  row_order <- lapply(seq_len(n_order), function(i) if (rev[i]) -xtfrm.default(x[[order[i]]]) else x[[order[i]]])
  row_order <- do.call("order", row_order)
  x <- t.default(df_to_matrix(x[row_order, , drop = FALSE]))
  if (sort_type == "rgb") rgb2hex(x) else hsl2hex(x)
}

# Extract colors ----------------------------------------------------------

#' Extract palette from image
#'
#' @param file_path Path to image file including extension. File types supported: jpg, png, tiff, svg, pdf, website url
#' @param n Number of colors to include in palette. Default is `10`
#' @param max_pixels Maximum number of pixels in largest dimension to use for file compression. Default is `100`
#' @returns Palette of hexadecimal codes as character vector
#' @noRd
get_pal_image <- function(file_path, n = 10, max_pixels = 100) {
  pkg_required("EBImage")
  pkg_required("magick")
  ext <- str_file_ext(file_path)
  file_path <- if (ext %in% c("pdf", "svg")) {
    image_png <- if (ext == "pdf") {
      magick::image_read_pdf(file_path)
    } else {
      magick::image_read_svg(file_path)
    }
    image_png <- magick::image_convert(image_png, format = "png")
    magick::image_write(image_png, tempfile(fileext = ".png"), format = "png")
  } else {
    file_path
  }
  img <- EBImage::readImage(file_path)
  dims <- dim(img)
  if (max(dims[c(1, 2)]) > max_pixels) {
    img <- if (dims[1L] > dims[2L]) EBImage::resize(img, w = max_pixels) else EBImage::resize(img, h = max_pixels)
  }
  #z <- as.data.frame.table(img, responseName = "value", stringsAsFactors = FALSE)
  z <- crossings(dimnames(provideDimnames(img)), .prefix_colnames = "Var")
  z$value <- c(img)
  for (i in vars_which(z, function(x) !is.numeric(x))) {
    z[[i]] <- as_numeric_factor(z[[i]])
  }
  img <- tidyr::pivot_wider(z, id_cols = c(Var1, Var2), values_from = value, names_from = Var3)
  img$Var1 <- -img$Var1
  dominant_colors <- kmeans(img[, 3:5], centers = n, nstart = 3, iter.max = 100)
  as.character(sort.int(grDevices::rgb(dominant_colors$centers)))
}

#' Convert dots input to character vector of colors
#'
#' @param ... List, character vector, or comma separated list of colors as quoted color names or hexadecimal codes
#' @noRd
.color_input <- function(...) if (is.list(colors <- c(...))) unlist(colors, recursive = FALSE) else colors
